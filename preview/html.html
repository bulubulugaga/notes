<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:html</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="-">标签</h1>
<h2 id="-">链接</h2>
<h3 id="-target-">超链接target属性的取值和应用</h3>
<table>
<thead>
<tr>
<th style="text-align:center">取值</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">_self</td>
<td>默认值，在当前窗口或者框架(包括iframe)中加载目标文档。</td>
</tr>
<tr>
<td style="text-align:center">_blank</td>
<td>在新窗口中打开被链接文档，iframe中也是</td>
</tr>
<tr>
<td style="text-align:center">_parent</td>
<td>在父框架中打开（比如你在页面中嵌套一个iframe1，再在iframe1里面嵌套一个iframe2，那么iframe2里的超链接就会在iframe1打开，并且会覆盖iframe1的所有内容），当a标签本身在顶层时，则与 _self 相同</td>
</tr>
<tr>
<td style="text-align:center">_top</td>
<td>在浏览器的整个窗口显示内容，忽略掉所有的框架结构</td>
</tr>
<tr>
<td style="text-align:center">framename</td>
<td>在指定的框架中打开被链接文档。</td>
</tr>
<tr>
<td style="text-align:center">任意字符</td>
<td>若该链接不是已打开的页面，则在新窗口中打开，与_blank一致；若该链接已经打开，则跳转到该标签页并刷新页面。</td>
</tr>
</tbody>
</table>
<h2 id="-">表单</h2>
<h3 id="label-">label的属性和作用</h3>
<pre><code>&lt;label for=&quot;name&quot; accesskey=&quot;N&quot;&gt;姓名：&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt;
&lt;label for=&quot;password&quot; accesskey=&quot;P&quot;&gt;密码&lt;/label&gt;&lt;input type=&quot;password&quot; id=&quot;password&quot; /&gt;
</code></pre><p>FOR属性：表示Label标签要绑定的HTML元素，你点击这个标签的时候，所绑定的元素将获取焦点。<br>ACCESSKEY属性：表示访问Label标签所绑定的元素的热键，当您按下热键，所绑定的元素将获取焦点。在这里必须指定for才能起作用。所设置的快捷键不能与浏览器的快捷键冲突，否则将优先激活浏览器的快捷键。  </p>
<h3 id="-">关闭表单自动完成</h3>
<blockquote>
<p>autocomplete=&quot;off&quot; 可放在表单，也可放在输入框   </p>
</blockquote>
<pre><code>&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; autocomplete=&quot;on&quot;&gt;
  First name:&lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;&lt;br /&gt;  &lt;!-- 需要设置name值 --&gt;
  Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; /&gt;&lt;br /&gt;
  E-mail: &lt;input type=&quot;email&quot; name=&quot;email&quot; autocomplete=&quot;off&quot; /&gt;&lt;br /&gt;
  &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;
</code></pre><h2 id="meta">meta</h2>
<h3 id="viewport">viewport</h3>
<p>viewport 就是视区窗口，也就是浏览器中显示网页的部分。PC 端上基本等于设备显示区域，但在移动端上 viewport 会超出设备的显示区域（即会有横向滚动条出现），设备默认的 viewport 在 980 – 1024 之间。  </p>
<p>为了让移动端可以很好地显示页面，因此需要对 viewport 进行设置。相关的设置值如下：   </p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">width</td>
<td style="text-align:center">设置layout viewport 的宽度，为一个正整数，或字符串&quot;width-device&quot;</td>
</tr>
<tr>
<td style="text-align:center">initial-scale</td>
<td style="text-align:center">设置页面的初始缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td style="text-align:center">minimum-scale</td>
<td style="text-align:center">允许用户的最小缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td style="text-align:center">maximum-scale</td>
<td style="text-align:center">允许用户的最大缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td style="text-align:center">height</td>
<td style="text-align:center">设置layout viewport  的高度，这个属性对我们并不重要，很少使用</td>
</tr>
<tr>
<td style="text-align:center">user-scalable</td>
<td style="text-align:center">是否允许用户进行缩放，值为&quot;no&quot;或&quot;yes&quot;, no 代表不允许，yes代表允许</td>
</tr>
</tbody>
</table>
<p>代码演示：</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;
</code></pre><h1 id="-">题库</h1>
<h2 id="-">问题</h2>
<h3 id="-link-import-">页面导入样式时，使用link和@import有什么区别</h3>
<ol>
<li>link是HTML标签，@import是css提供的。   </li>
<li>link引入的样式页面加载时同时加载，@import引入的样式需等页面加载完成后再加载。   </li>
<li>link没有兼容性问题，@import不兼容ie5以下。   </li>
<li>link可以通过js操作DOM动态引入样式表改变样式，而@import不可以。   </li>
</ol>
<h3 id="html5-">HTML5的离线储存</h3>
<ul>
<li>HTML5离线存储存储功能非常强大，它的作用（优点）是：在用户没有与因特网连接时，可以正常访问站点或应用，加快资源的加载速度，减少服务器负载，在用户与因特网连接时，自动更新缓存数据。   </li>
<li><strong>使用：</strong><br>首先，在html页面头部加入一个manifest的属性:<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html manifest = &quot;cache.manifest&quot;&gt;
...
&lt;/html&gt;
</code></pre>然后创建manifest.appcache文件：<pre><code>CACHE MANIFEST
#v0.11
CACHE:
js/app.js
css/style.css
NETWORK:
resourse/logo.png
FALLBACK:
offline.html
</code></pre><ul>
<li>CACHE MANIFEST放在第一行</li>
<li>CACHE: 表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要列出来</li>
<li>NETWORK: 表示在线才能访问的资源列表，如果CACHE列表里也存在，则CACHE优先级更高<br>可以使用 “*” 来指示所有其他资源/文件都需要因特网连接：<blockquote>
<p>NETWORK: *</p>
</blockquote>
</li>
<li>FALLBACK: 在此标题下列出的文件规定当页面无法访问时的回退页面。比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。</li>
</ul>
</li>
<li><strong>原理：</strong><br>HTML5的离线存储是基于一个新建的.appcache文件的，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</li>
<li><strong>浏览器如何解析manifest</strong><br>在线情况：浏览器发现html头部有manifest属性，他会请求manifest文件，如果是第一次访问，那么浏览器会根据manifest文件的内容下载相应的资源并且进行离线存储.如果已经访问过并存储，那么浏览器使用离线的资源价值，然后对比新的文件，如果没有发生改变就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储<br>离线情况：浏览器就直接使用离线存储资源  </li>
<li><strong>注意</strong>   <ul>
<li>站点离线存储的容量限制是5M</li>
<li>如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器继续全部使用老的缓存</li>
<li>引用manifest的html必须与manifest文件同源，在同一个域下</li>
<li>在manifest中使用的相对路径，相对参照物为manifest文件</li>
<li>CACHE MANIFEST字符串硬在第一行，且必不可少</li>
<li>系统会自动缓存引用清单文件的HTML文件</li>
<li>manifest文件中CACHE则与NETWORK，FALLBACK的位置顺序没有关系，如果是隐式声明需要在最前面</li>
<li>FALLBACK中的资源必须和manifest文件同源</li>
<li>当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问</li>
<li>当manifest文件发生改变时，资源请求本身也会触发更新  </li>
</ul>
</li>
</ul>
<p>其他相关参考<a href="https://juejin.cn/post/6844903902727372807">《HTML5的文件离线存储怎么使用,工作原理?》</a>   </p>
<h3 id="-">浏览器内多个标签页间的通信</h3>
<p>总结：   </p>
<ol>
<li>cookie + setInterval方式</li>
<li>localStorage方式</li>
<li>webSocket方式</li>
<li>SharedWorker方式     </li>
</ol>
<p>详情: <a href="https://blog.csdn.net/weixin_46399753/article/details/105211771">《实现浏览器内多个标签页面之间通信的四种方法?》</a>  </p>
<h3 id="-">浏览器内核</h3>
<p>浏览器内核主要分成两个部分：渲染引擎(layout engineer 或者 Rendering Engine)和JS引擎。<br><strong>渲染引擎</strong>：负责取得网页的内容(html，xml和图像等)，整理讯息(例如加入css)，以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同。所有网页浏览器、电子邮件客户端以及它需要编辑、显示网络内容的应用程序都需要内核。<br><strong>JS引擎</strong>：解析和执行JavaScript来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 </p>
<p><strong>常用的浏览器内核</strong><br>1、Trident(IE内核)<br>国内很多的双核浏览器的其中一核便是 Trident，也有称&quot;兼容模式&quot;。<br>代表：IE、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。<br>2、Gecko(firefox)<br>Gecko(Firefox 内核)： Mozilla FireFox(火狐浏览器) 采用该内核，代码完全公开，因此，其可开发程度很高，但今年打开速度慢、升级频繁。<br>3、webkit(Safari)<br>Safari 是苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了）。<br>代表浏览器：傲游浏览器3、 Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器。<br>4、Chromium/Bink(chrome)<br>Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。<br>大部分国产浏览器最新版都采用Blink内核。<br>5、Presto(Opera)<br>Presto 是挪威产浏览器 opera 的 &quot;前任&quot; 内核，最新版已经与谷歌一致。    </p>
<p><strong>移动端的浏览器内核主要说的是系统内置浏览器的内核</strong>
目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中<br>iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，<br>Android 4.4 之前的 Android 系统浏览器内核是 WebKit，<br>Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，<br>Windows Phone 8 系统浏览器内核是 Trident。  </p>
<p><a href="https://www.cnblogs.com/chengzp/p/7757844.html">更多浏览器内核详细信息</a></p>
<h3 id="html5-doctype">HTML5为什么只需要写&lt;!DOCTYPE&gt;</h3>
<p>在 HTML 4.01 中有三种 &lt;!DOCTYPE&gt; 声明，在 HTML5 中只有一种。<br><strong>HTML 5</strong>  </p>
<pre><code>&lt;!DOCTYPE html&gt;
</code></pre><p><strong>HTML 4.01 Strict</strong><br>该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。   </p>
<pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
</code></pre><p><strong>HTML 4.01 Transitional</strong><br>该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。  </p>
<pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
</code></pre><p><strong>HTML 4.01 Frameset</strong><br>该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。   </p>
<pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;
</code></pre><p>HTML5 不基于 SGML, 因此不要要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。<br>HTML4.0.1 基于 SGML ，所以需要对 DTD 进行引用，才能让浏览器知道该文档所使用的的文档类型，正确呈现内容。   </p>
<p><strong>SGML</strong>: SGML 是国际上定义电子文档和内容描述的标准。它源于1969年IBM公司开发的文档描述语言 GML ，GML主要用来解决不同系统中文档格式不同的问题。后经过多年发展，1986 年经 ISO 批准为国际标 准ISO8897，并被称为 SGML。<br>制定 SGML 的基本思想是把文档的内容与样式分开。在 SGML 中，标记分两种：一种用来描述文档显示的样式，称为程序标记；另一种用来描述文档中语句的用途，称为描述标记。一个 SGML 文件通常分三个层次：结构、内容和样式。结构为组织文档的元素提供框架，内容是信息本身，样式控制内容的显示。<br>SGML 的平台无关性、结构化、可扩展等特性，使得它使用范围很广，被许多大型公司用来创建和发布信息。   </p>
<p><strong>DTD</strong>: 文档类型定义（Document Type Definition，DTD）   </p>
<p>&lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于 &lt; html &gt; 标签之前。<br>&lt;!DOCTYPE&gt; 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。</p>
<h3 id="title-h1-b-strong-i-em-">title与h1 b与strong i与em的区别</h3>
<p><strong>title与h1的区别</strong><br>定义：<br>&emsp;title是网站标题<br>&emsp;h1是文章主题<br>作用：<br>&emsp;title概括网站信息，可以直接告诉搜索引擎和用户这个网站是关于什么主题和内容的，是显示在网页Tab栏里的。<br>&emsp;h1突出文章主题，面对用户，更突出其视觉效果，指向页面主体信息，是显示在网页中的。    </p>
<p><strong>b与strong的区别</strong><br>定义：<br>&emsp;b(bold)是实体标签，用来给文字加粗。<br>&emsp;strong是逻辑标签，作用是加强字符语气。   </p>
<p>区别：<br>&emsp;b标签只是加粗的样式，没有实际含义，常用来表达无强调或着重意味的粗体文字，如文章摘要中的关键词、 评测文章中的产品名称、文章的导言。<br>&emsp;strong表示标签内字符重要，用以强调，其默认格式是加粗，但是可以通 过CSS添加样式，使用别的样式强调。   </p>
<p><strong>i与em的区别</strong><br>定义：<br>&emsp;i(italic)是实体标签，用来使字符倾斜。<br>&emsp;em(emphasis)是逻辑标签，作用是强调文本内容。  </p>
<p>区别：<br>&emsp;i标签只是斜体的样式，没有实际含义，常用来表达无强调或着重意味的斜体，比如生物学名、术语、外来语。<br>&emsp;em表示标签内字符重要，用以强调，其默认格式是斜体，但是可以通过CSS添加样式。   </p>
<p>建议：对于搜索引擎来说 strong 和 em 比 b 和 i 要重视的多。为了符合现在W3C的标准，还是推荐使用strong和em标签。   </p>
<p>其它：<br>&emsp;物理元素所强调的是一种物理行为，比如说我把一段文字用b标记加粗了，我的意思是告诉浏览器应该给我加粗了显示这段文字，从单词的语义也可以分析得出，b是Bold(加粗)的简写，所以这个B标记所传达的意思只是加粗，没有任何其它的作用。<br>&emsp;而Strong我们从字面理解就可以知道他是强调的意思，所以我们用这个标记向浏览器传达了一个强调某段文字的消息，而这个Strong就是我们所说的逻辑元素，他是强调文档逻辑的，并非是通知浏览器应该如何显示。</p>
<h2 id="-">编程</h2>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>